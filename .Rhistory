if (srednica_y <= 0) {
stop("Argument `ymax` musi przyjmować wartość większą niż `ymin`")
}
r = srednica_y / 2
if(srednica_y != srednica_x){
stop("Promień nie jest taki sam w innych punktach koła")
}
r = srednica_x / 2
if(srednica_y != srednica_x){
stop("Promień nie jest taki sam w innych punktach koła")
}
x = matrix(values, ncol = 2)
structure(x, class = "kolo")
}
obwod.kolo = function(x){
r = (x[1, 2] - x[1, 1]) / 2
wynik = 2*pi*r
wynik
}
obwod = function(x){
UseMethod("obwod")
}
obwod(kolo(10, 90, 20, 100))
UseMethod("obwod", class)
UseMethod("obwod", "kolo")
UseMethod("x")
UseMethod(x)
UseMethod('obwod')
obwod = function(x){
UseMethod("obwod")
}
UseMethod("obwod")
obwod = function(x){
UseMethod("obwod")
}
obwod = function(x){
UseMethod(x)
}
obwod.kolo = function(x){
r = (x[1, 2] - x[1, 1]) / 2
wynik = 2*pi*r
wynik
}
obwod(kolo(10, 90, 20, 100))
obwod.kolo = function(x){
r = (x[1, 2] - x[1, 1]) / 2
wynik = 2*pi*r
wynik
}
obwod(kolo(10, 90, 20, 100))
obwod = function(x){
UseMethod("obwod")
}
obwod(kolo(10, 90, 20, 100))
obwod.kolo = function(x){
r = (x[1, 2] - x[1, 1]) / 2
wynik = 2*pi*r
wynik
}
obwod.trojkat = function(trojkat){
b1 = sqrt(((trojkat['a','x']-trojkat['b','x'])^2)+((trojkat['a','y']-trojkat['b', 'y'])^2))
b2 = sqrt(((trojkat['b','x']-trojkat['c','x'])^2)+((trojkat['b','y']-trojkat['c', 'y'])^2))
b3 = sqrt(((trojkat['a','x']-trojkat['c','x'])^2)+((trojkat['a','y']-trojkat['c', 'y'])^2))
print(b1+b2+b3)
}
#'
#' @return wartosc numeryczna - obwod obiektu o klasie "trojkat".
#' @export
#'
#' @examples
#' obwod.trojkat(trojkat(pi, pi + 1, 13, 14, 20, 40))
#'
#' ob = trojkat(1, 2, 3, 1, 2, 3)
#' obwod.trojkat(ob)
#'
obwod = function(trojkat){
UseMethod("obwod")
}
obwod.trojkat(trojkat(pi, pi + 1, 13, 14, 20, 40))
obwod = function(kolo){
UseMethod("obwod")
}
obwod.prostokat = function(prostokat){
a = prostokat[1, 2] - prostokat[1, 1]
b = prostokat[2, 2] - prostokat[2, 1]
a + a + b + b
}
obwod(prostokat(133, 130, 138, 135))
obwod.prostokat(prostokat(133, 130, 138, 135))
obwod_prostokat(prostokat(133, 130, 138, 135))
obwod_prostokat = function(prostokat){
a = prostokat[1, 2] - prostokat[1, 1]
b = prostokat[2, 2] - prostokat[2, 1]
a + a + b + b
}
obwod_prostokat(prostokat(133, 130, 138, 135))
x = matrix(values, ncol = 2)
prostokat = function(xmin, ymin, xmax, ymax){
values = c(xmin, ymin, xmax, ymax)
if (!(is.numeric(values))){
stop("Błąd! Upewnij się, czy wszystkie argumenty są typu numerycznego")
}
if (!all(c(length(xmin), length(ymin), length(xmax), length(ymax)) == 1)){
stop("Każdy z argumentów może przyjmować tylko jedną wartość")
}
x_range = values[3] - values[1]
if (x_range <= 0){
stop("`xmax` musi przyjmować wartość większą niż `xmin`")
}
y_range = values[4] - values[2]
if (y_range <= 0) {
stop("`ymax` musi przyjmować wartość większą niż `ymin`")
}
x = matrix(values, ncol = 2)
structure(x, class = "prostokat")
}
obwod_prostokat(prostokat(133, 130, 138, 135))
prostokat = function(xmin, ymin, xmax, ymax){
values = c(xmin, ymin, xmax, ymax)
if (!(is.numeric(values))){
stop("Błąd! Upewnij się, czy wszystkie argumenty są typu numerycznego")
}
if (!all(c(length(xmin), length(ymin), length(xmax), length(ymax)) == 1)){
stop("Każdy z argumentów może przyjmować tylko jedną wartość")
}
x_range = values[3] - values[1]
if (x_range <= 0){
stop("`xmax` musi przyjmować wartość większą niż `xmin`")
}
y_range = values[4] - values[2]
if (y_range <= 0) {
stop("`ymax` musi przyjmować wartość większą niż `ymin`")
}
x = matrix(values, ncol = 2)
structure(x, class = "prostokat")
}
prostokat(log10(10), pi, 144, 192)
obwod_prostokat(prostokat(133, 130, 138, 135))
obwod_prostokat = function(prostokat){
a = prostokat[1, 2] - prostokat[1, 1]
b = prostokat[2, 2] - prostokat[2, 1]
a + a + b + b
}
obwod_prostokat(prostokat(133, 130, 138, 135))
obwod(prostokat(133, 130, 138, 135)
pole_powierzchni_prostokat = function(x){
a = x[1, 2] - x[1, 1]
b = x[2, 2] - x[2, 1]
a * b
}
pole_powierzchni_prostokat = function(x){
a = x[1, 2] - x[1, 1]
b = x[2, 2] - x[2, 1]
a * b
}
ob = kolo(pi, 300, 2*pi, 310)
kolo = function(xmin, ymin, xmax, ymax){
values = c(xmin, ymin, xmax, ymax)
if (!(is.numeric(values))){
stop("Błąd! Upewnij się, czy wszystkie argumenty są typu numerycznego")
}
if (!all(c(length(xmin), length(ymin), length(xmax), length(ymax)) == 1)){
stop("Każdy z argumentów może przyjmować tylko jedną wartość")
}
srednica_x = values[3] - values[1]
if (srednica_x <= 0){
stop("Argument `xmax` musi przyjmować wartość większą niż `xmin`")
}
srednica_y = values[4] - values[2]
if (srednica_y <= 0) {
stop("Argument `ymax` musi przyjmować wartość większą niż `ymin`")
}
r = srednica_y / 2
if(srednica_y != srednica_x){
stop("Promień nie jest taki sam w innych punktach koła")
}
r = srednica_x / 2
if(srednica_y != srednica_x){
stop("Promień nie jest taki sam w innych punktach koła")
}
x = matrix(values, ncol = 2)
structure(x, class = "kolo")
}
ob = kolo(pi, 300, 2*pi, 310)
ob = kolo(pi, 300, pi, 310)
ob = kolo(pi, 300, pi+10, 310)
obwod_kolo = function(kolo){
r = (kolo[1, 2] - kolo[1, 1]) / 2
wynik = 2*pi*r
wynik
}
kolo(pi, 300, pi+10, 310)
fajne_kolo = kolo(pi, 300, pi+10, 310)
trojkat_tomek = trojkat(pi, pi + 1, 13, 14, 20, 40)
if (!(is.numeric(values))){
stop("Błąd! Upewnij się, czy wszystkie argumenty są typu numerycznego")
}
trojkat = function(x1, x2, x3, y1, y2, y3){
values = c(x1, x2, x3, y1, y2, y3)
if (!(is.numeric(values))){
stop("Błąd! Upewnij się, czy wszystkie argumenty są typu numerycznego")
}
if (!all(c(length(x1), length(x2), length(x3),
length(y1), length(y2), length(y3)) == 1)){
stop("Każdy z argumentów może przyjmować tylko jedną wartość")
}
if (values[c(1,4)] == values[c(2,5)] || values[c(1,4)] == values[c(3,6)]
|| values[c(2,5)] == values[c(3,6)]){
stop("Punkty muszą być w różnych miejscach.")
}
x = matrix(values, ncol = 2, dimnames = list(c("a", "b", "c"), c("x","y")))
structure(x, class = "trojkat")
}
trojkat_tomek = trojkat(pi, pi + 1, 13, 14, 20, 40)
pole_powierzchni_trojkat(trojkat_tomek)
pole_powierzchni_trojkat = function(x){
b1 = sqrt(((x['a','x']-x['b','x'])^2)+((x['a','y']-x['b', 'y'])^2))
b2 = sqrt(((x['b','x']-x['c','x'])^2)+((x['b','y']-x['c', 'y'])^2))
b3 = sqrt(((x['a','x']-x['c','x'])^2)+((x['a','y']-x['c', 'y'])^2))
boki = c(b1, b2, b3)
boki
#rownoboczny
if(boki[1] == boki[2] && boki[2] == boki[3] && boki[1] == boki[3]){
pole = ((((boki[1])^2)*sqrt(3))/4)
}
#rownoramienny
if(boki[1] == boki[2] && boki[1] != boki[3] && boki[2] != boki[3]){
h = sqrt((boki[3]^2) - (((1/2)*boki[1])^2))
pole = ((boki[3]*h)/2)
}
if(boki[3] == boki[2] && boki[1] != boki[3] && boki[2] != boki[1]){
h = sqrt((boki[1]^2) - (((1/2)*boki[3])^2))
pole = ((boki[1]*h)/2)
}
if(boki[1] == boki[3] && boki[2] != boki[3] && boki[2] != boki[1]){
h = sqrt((boki[1]^2) - (((1/2)*boki[2])^2))
pole = ((boki[2]*h)/2)
}
pole
}
pole_powierzchni_trojkat(trojkat_tomek)
pole = ((boki[2]*h)/2)
trojkat(pi, pi + 1, 13, 14, 20, 40)
pole_powierzchni_trojkat(trojkat(3, 0, 1, 6, 7, 5))
przekatna_kwadrat
przekatna(kwadrat(1, 1, 4, 4))
przekatna_kwadrat = function(x){
a = x[1, 2] - x[1, 1]
a * sqrt(2)
}
przekatna_kwadrat(kwadrat(1, 1, 4, 4))
structure(x, class = "kwadrat")
kwadrat = function(xmin, ymin, xmax, ymax){
values = c(xmin, ymin, xmax, ymax)
if (xmax - xmin != ymax - ymin){
stop("Obiekt o takich współrzędnych nie jest kwadratem :(")
}
if (!(is.numeric(values))){
stop("Błąd! Upewnij się, czy wszystkie argumenty są typu numerycznego")
}
if (!all(c(length(xmin), length(ymin), length(xmax), length(ymax)) == 1)){
stop("Każdy z argumentów może przyjmować tylko jedną wartość")
}
x_range = values[3] - values[1]
if (x_range <= 0){
stop("`xmax` musi przyjmować wartość większą niż `xmin`")
}
y_range = values[4] - values[2]
if (y_range <= 0) {
stop("`ymax` musi przyjmować wartość większą niż `ymin`")
}
x = matrix(values, ncol = 2)
structure(x, class = "kwadrat")
}
przekatna_kwadrat = function(x){
a = x[1, 2] - x[1, 1]
a * sqrt(2)
}
#'
#' @examples
#' przekatna_prostokat(prostokat(100, 101, 102, 103))
#'
#' z = prostokat(4, 5, 6, 6)
#' przekatna_prostokat(z)
#'
#' m = prostokat(log10(100), 1, 80, 2)
#' przekatna_prostokat(m)
#'
przekatna_prostokat = function(x){
a = x[1, 2] - x[1, 1]
b = x[2, 2] - x[2, 1]
sqrt((a ^ 2) + (b ^ 2))
}
if (x_range <= 0){
stop("`xmax` musi przyjmować wartość większą niż `xmin`")
}
prostokat = function(xmin, ymin, xmax, ymax){
values = c(xmin, ymin, xmax, ymax)
if (!(is.numeric(values))){
stop("Błąd! Upewnij się, czy wszystkie argumenty są typu numerycznego")
}
if (!all(c(length(xmin), length(ymin), length(xmax), length(ymax)) == 1)){
stop("Każdy z argumentów może przyjmować tylko jedną wartość")
}
x_range = values[3] - values[1]
if (x_range <= 0){
stop("`xmax` musi przyjmować wartość większą niż `xmin`")
}
y_range = values[4] - values[2]
if (y_range <= 0) {
stop("`ymax` musi przyjmować wartość większą niż `ymin`")
}
x = matrix(values, ncol = 2)
structure(x, class = "prostokat")
}
przekatna_prostokat(prostokat(100, 101, 102, 103))
przekatna_prostokat(prostokat(100, 101, 102, 103))
kwadracik = kwadrat(4, 5, 6, 7)
przekatna_kwadrat(kwadracik)
kolo = function(xmin, ymin, xmax, ymax){
values = c(xmin, ymin, xmax, ymax)
if (!(is.numeric(values))){
stop("Błąd! Upewnij się, czy wszystkie argumenty są typu numerycznego")
}
if (!all(c(length(xmin), length(ymin), length(xmax), length(ymax)) == 1)){
stop("Każdy z argumentów może przyjmować tylko jedną wartość")
}
srednica_x = values[3] - values[1]
if (srednica_x <= 0){
stop("Argument `xmax` musi przyjmować wartość większą niż `xmin`")
}
srednica_y = values[4] - values[2]
if (srednica_y <= 0) {
stop("Argument `ymax` musi przyjmować wartość większą niż `ymin`")
}
r = srednica_y / 2
if(srednica_y != srednica_x){
stop("Promień nie jest taki sam w innych punktach koła")
}
r = srednica_x / 2
if(srednica_y != srednica_x){
stop("Promień nie jest taki sam w innych punktach koła")
}
x = matrix(values, ncol = 2)
structure(x, class = "kolo")
}
pole_wycinka = function(kolo, a){
r = (x[1, 2] - x[1, 1]) / 2
}
pole_wycinka(kolo(1, 9, 2, 10))
pole_wycinka(kolo(1, 9, 2, 10), 0)
pole_wycinka = function(kolo, a){
r = (x[1, 2] - x[1, 1]) / 2
}
pole_wycinka(kolo(1, 9, 2, 10), 0)
kolo(1, 9, 2, 10)
kolo(1, 9, 2, 10)[1]
pole_wycinka = function(kolo, a){
r = (kolo[1, 2] - kolo[1, 1]) / 2
}
pole_wycinka(kolo(1, 9, 2, 10), 0)
pole_wycinka = function(kolo, a){
r = (kolo[1, 2] - kolo[1, 1]) / 2
r
}
pole_wycinka(kolo(1, 9, 2, 10), 0)
kolo(1, 9, 2, 10)
cinka = function(kolo, a){
r = (kolo[1, 2]
kolo[1, 2]
kolo(1, 9, 2, 10)[1, 2]
pole_wycinka = function(kolo, a){
r = (kolo[1, 2] - kolo[1, 1]) / 2
r
}
if(a < 0){
stop("Błąd! Wartość kąta nie może być mniejsza niż 0!")
}
pole_wycinka = function(kolo, a){
r = (kolo[1, 2] - kolo[1, 1]) / 2
if(a > 360){
stop("Błąd! Wartość kąta nie może być większa niż 360!")
}
if(a < 0){
stop("Błąd! Wartość kąta nie może być mniejsza niż 0!")
}
}
pole_wycinka(kolo(1, 9, 2, 10), 4)
pole_wycinka = function(kolo, a){
r = (kolo[1, 2] - kolo[1, 1]) / 2
if(a > 360){
stop("Błąd! Wartość kąta nie może być większa niż 360!")
}
if(a < 0){
stop("Błąd! Wartość kąta nie może być mniejsza niż 0!")
}
wynik = (a/360)*pi*(r^2)
wynik
}
pole_wycinka(kolo(1, 9, 2, 10), 4)
pole_wycinka(kolo(1, 9, 2, 10), 0)
pole_wycinka(kolo(1, 9, 2, 10), -3)
pole_wycinka(kolo(1, 9, 2, 10), 180)
pole_wycinka(kolo(30, 20, 150, 100), 180)
pole_wycinka(kolo(150, 100, 150, 100), 180)
pole_wycinka(kolo(150, 150, 300, 300), 180)
pole_wycinka(kolo(150, 150, 300, 300), 1)
pole_wycinka = function(kolo, a){
r = (kolo[1, 2] - kolo[1, 1]) / 2
if(is.numeric(a) == FALSE){
stop("Argument 'a' musi być numeryczny")
}
if(a > 360){
stop("Błąd! Wartość kąta nie może być większa niż 360!")
}
if(a < 0){
stop("Błąd! Wartość kąta nie może być mniejsza niż 0!")
}
wynik = (a/360)*pi*(r^2)
wynik
}
pole_wycinka(kolo(150, 150, 300, 300), FALSE)
dlugosc_luku = function(kolo, a){
r = (kolo[1, 2] - kolo[1, 1]) / 2
if(is.numeric(a) == FALSE){
stop("Argument 'a' musi być numeryczny")
}
if(a > 360){
stop("Błąd! Wartość kąta nie może być większa niż 360!")
}
if(a < 0){
stop("Błąd! Wartość kąta nie może być mniejsza niż 0!")
}
wynik = (a/360)*2*pi*r
wynik
}
dlugosc_luku(kolo(1, 9, 2, 10), 4)
fajne_kolo = kolo(pi, 300, pi+10, 310)
dlugosc_luku(fajne_kolo)
dlugosc_luku(fajne_kolo, 85)
dlugosc_luku(kolo(1, 9, 2, 10), 180)
dlugosc_luku(kolo(150, 150, 300, 300), 1)
pole_wycinka(fajne_kolo, 180)
library(mathobjects)
usethis::use_readme_rmd()
install.packages("rmarkdown")
usethis::use_readme_rmd()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)```
---
output: github_document
---
<!-- README.md is generated from README.Rmd. Please edit that file -->
```{r, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
```
# mathobjects
<!-- badges: start -->
<!-- badges: end -->
The goal of mathobjects is to ...
## Installation
You can install the released version of mathobjects from [CRAN](https://CRAN.R-project.org) with:
``` r
install.packages("mathobjects")
```
And the development version from [GitHub](https://github.com/) with:
``` r
# install.packages("devtools")
devtools::install_github("spacea/projekt-2019-tyrcha")
```
## Example
This is a basic example which shows you how to solve a common problem:
```{r example}
library(mathobjects)
## basic example code
```
What is special about using `README.Rmd` instead of just `README.md`? You can include R chunks like so:
```{r cars}
summary(cars)
```
You'll still need to render `README.Rmd` regularly, to keep `README.md` up-to-date.
You can also embed plots, for example:
```{r pressure, echo = FALSE}
plot(pressure)
```
In that case, don't forget to commit and push the resulting figure files, so they display on GitHub!
?mathobjects
??mathobjects
README
README.Rmd
plot(pressure)
# mathobjects
devtools::install_github("spacea/projekt-2019-tyrcha")
summary(cars)
kwadrat(4, 4, 192, 192)
pole_powierzchni_kwadrat(kwadrat(1, 1, 2, 2))
library(mathobjects)
